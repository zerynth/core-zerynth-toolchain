"""
.. _ztc-cmd-thing:

*****************
Connected Devices
*****************

The Zerynth Advanced Device Manager (ADM) allows connections between the devices programmed with Zerynth and the ADM sandbox instance hosted on the Zerynth backend server.
The ADM adds to each connected device the following functionalities:

    * executing functions triggered by a remote request (remote procedure call)
    * performing over the air (OTA) firmware update
    * displaying and interacting with a graphical user interface both on a mobile app or desktop browser

Such functionalities can be configured and controlled through the following ZTC commands:

* :ref:`Create a connected device <ztc-cmd-thing-add>`
* :ref:`Retrieve info on a connected device <ztc-cmd-thing-info>`
* :ref:`Set properties of a connected device <ztc-cmd-thing-config>`
* :ref:`Retrieve the list of connected devices <ztc-cmd-thing-list>`

* :ref:`Create groups of devices <ztc-cmd-thing-group-add>`
* :ref:`Add a connected device to a group <ztc-cmd-thing-group-config>`
* :ref:`List groups of devices <ztc-cmd-thing-group-list>`

* :ref:`Create a graphical template <ztc-cmd-thing-template-add>`
* :ref:`Update a graphical template <ztc-cmd-thing-template-upload>`
* :ref:`List all graphical templates <ztc-cmd-thing-template-list>`


Details about the ADM can be found here. Info on how to write a Zerynth script for the ADM can be found here.

    """

from base import *
import click
import base64


@cli.group(help="Manage connected devices")
def thing():
    pass
    

@thing.command("add",help="")
@click.argument("name")
@click.option("--platform",default="",type=str)
@click.option("--location",default="",type=str)
@click.option("--description",default="",type=str)
@click.option("--lat",default=0.0, type=float)
@click.option("--lon",default=0.0, type=float)
@click.option("--tag",multiple=True, type=str)
def __add(platform,name,location,tag,lat,lon,description):
    """ 

.. _ztc-cmd-thing-add:

Create a connected device
-------------------------

In order to connect a physical device to the ADM, a bit of device provisioning must be made. In particular, a new connected device
instance must be created on the ADM and the assigned credentials used in the script running on the physical device. 

The command: ::

    ztc thing add name

creates a new connected device instance with name :samp:`name` in the ADM server. Such instance can have many different properties, but only a subset of them is mandatory and generated by the ADM:

* :samp:`uid`: the unique identifier of the connected device
* :samp:`token`: the security token used to authenticate the physical device to the ADM

Additional properties can be specified at the moment of creation by specifying the corresponding options:

* :option:`--location loc` adds the description of the location the physical device is placed
* :option:`--lat lat --lon lon` attaches coordinates to the device
* :option:`--description desc` specifies the device description
* :option:`--tag tag` attaches a set of tags to the device (the option can be given multiple times)

Each Zerynth user can create an unlimited number of connected devices instances, however only a subset of them is allowed to be connected to the ADM at the same moment.

    """
    thinfo = {
        "name":name,
        "platform":platform,
        "location":location,
        "description": description,
        "tags": tag,
        "geo": [lat,lon]
    }
    try:
        res = zpost(url=env.thing.devices, data=thinfo,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            thinfo["uid"]=rj["data"]["uid"]
            info("Thing",name,"created with uid:", thinfo["uid"])
        else:
            critical("Error while creating Thing:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't create Thing", exc=e)




@thing.command("info",help="")
@click.argument("uid")
def __info(uid):
    """

.. _ztc-cmd-thing-info:

Retrieves device info
---------------------

The command: ::

    ztc thing info uid

retrieves information about the connected device with unique identifier :samp:`uid`.

The information retrieved consists in:

* :samp:`token`, the security token for the device
* :samp:`name`, the device name
* :samp:`description`, the device description
* :samp:`location`, the description of the device location
* :samp:`geo`, the latitude and longitude of the device position
* :samp:`groups`, the list of groups the device belongs to
* :samp:`last_seen`, the time of the last detected presence of the connected device
* :samp:`online`, the status of the device connection
* :samp:`platform`, the type of the physical device using this connected device credentials
* :samp:`notifications`, a boolean determing if mobile notifications are enabled for this device

    """

    try:
        res = zget(url=env.thing.config%uid)
        rj = res.json()
        if rj["status"] == "success":
            if env.human:
                table=[]
                k = rj["data"]
                table.append([k["platform"],k["uid"],k["token"],k["name"],k["description"],k["location"],k["geo"],k.get("groups",[]),k.get("last_seen"),k.get("online",False),k["notifications"]])
                log_table(table,headers=["Target","UID","Token","Name","Desc","Location","Coords","Groups","Last Seen","Online","Notifications"])
            else:
                log_json(rj["data"])
        else:
            critical("Error while getting Thing:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't get Thing", exc=e)
    

@thing.command("config",help="")
@click.argument("uid")
@click.option("--name",default="",type=str)
@click.option("--location",default="",type=str)
@click.option("--description",default="",type=str)
@click.option("--lat",default=0.0, type=float)
@click.option("--lon",default=0.0, type=float)
@click.option("--template",default=None, type=str)
@click.option("--token",default=False,flag_value=True)
def __config(uid,name,location,description,lat,lon,template,token):
    """

.. _ztc-cmd-thing-config:

Configure a device
------------------

The command: ::

    ztc thing config uid

sets the properties of the connected device with unique identifier :samp:`uid`.

The properties are specified with the following options:

* :option:`--name name`, changes the device name
* :option:`--description desc `, changes the device description
* :option:`--location loc`, changes the device location
* :option:`--lat x / --lon y`, change the device coordinates
* :option:`--token`, asks for a new security token
* :option:`--template template_uid`, sets the device template

    """
    data = {}
    if name:
        data["name"]=name
    if location:
        data["location"]=location
    if description:
        data["description"]=description
    if lat and lon:
        data["geo"]=[lat,lon]
    if template is not None:
        data["template"] = template
    if token:
        data["token"] = True
    try:
        res = zput(url=env.thing.config%uid,data=data)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error while getting Thing:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't get Thing", exc=e)

@thing.command("list",help="")
@click.option("--from","_from",default=0,type=int,help="skip the first n connected devices")
@click.option("--status",default="all",type=click.Choice(["all","online","offline"]),help="skip the first n Things")
def __list(_from,status):
    """

.. _ztc-cmd-thing-list:

Connected devices list
----------------------

The command: ::

    ztc thing config list

retrieves the list of connected devices. Options can be specified to filter the results:

* :option:`--from n`, skips the first :samp:`n` connected devices. Default :samp:`n` is zero.
* :option:`--status online/offline`, filters connected devices based on online status. If not given, all devices are retrieved

    """
    table=[]
    try:
        prms = {"from":_from,"status":status}
        res = zget(url=env.thing.devices,params=prms)
        rj = res.json()
        if rj["status"]=="success":
            if env.human:
                for k in rj["data"]["devices"]:
                    table.append([_from,k["platform"],k["uid"],k["token"],k["name"],k["description"],k["location"],k["geo"],k.get("groups",[]),k.get("last_seen",False),k.get("online",False),k["notifications"]])
                    _from += 1
                log_table(table,headers=[str(rj["data"]["total"]),"Target","UID","Token","Name","Desc","Location","Coords","Groups","Last Seen","Online","Notifications"])
            else:
                log_json(rj["data"])
        else:
            critical("Can't get thing list",rj["message"])
    except Exception as e:
        critical("Can't get thing list",exc=e)





########### GROUPS

@thing.group("group",help="")
def group():
    pass


@group.command("add",help="")
@click.argument("name")
def __add_group(name):
    """

.. _ztc-cmd-thing-group-add:

Create a group of devices
-------------------------

The command: ::

    ztc thing group add name

creates a group named :samp:`name`, initially empty. 
Devices can be added to the group with the :ref:`config <ztc-thing-group-config>` command.


    """
    grinfo = {"name":name}
    try:
        res = zpost(url=env.thing.groups, data=grinfo,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            if env.human:
                info("Group",name,"created with uid",rj["data"]["uid"])
            else:
                log_json(rj["data"])
        else:
            critical("Error while creating group:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't create group", exc=e)


@group.command("config",help="")
@click.argument("uid")
@click.option("--add",multiple=True,type=str)
@click.option("--remove",multiple=True,type=str)
def __config_group(uid,add,remove):
    """
.. _ztc-cmd-thing-group-config:

Group configuration
-------------------

The command: ::

    ztc thing group config uid --add dev0_uid --remove dev1_uid

can be used to add or remove devices (identified by their uids :samp:`dev0_uid` and :samp:`dev1_uid`) to the group identifiedby :samp:`uid`.

The options :option:`--add` and :option:`--remove` can be repeated multiple times in the same command.

    """
    data = {}
    for x in add:
        data[x]=1
    for x in remove:
        data[x]=0
    try:
        res = zput(url=env.thing.group%uid, data=data,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't update group", exc=e)


@group.command("list",help="")
@click.option("--from","_from",default=0,type=int,help="skip the first n groups")
def __groups(_from):
    """

.. _ztc-cmd-thing-group-list:

Group configuration
-------------------

The command: ::

    ztc thing group list

retrieves the list of all groups. The option :option:`--from n` can be used to skip the first :samp:`n` groups.

    """    
    table=[]
    try:
        prms = {"from":_from}
        res = zget(url=env.thing.groups,params=prms)
        rj = res.json()
        if rj["status"]=="success":
            if env.human:
                for k in rj["data"]["groups"]:
                    table.append([_from,k["uid"],k["name"],k["createdAt"]])
                    _from += 1
                log_table(table,headers=[str(rj["data"]["total"]),"UID","Group","Created"])
            else:
                log_json(rj["data"])
        else:
            critical("Can't get groups list",rj["message"])
    except Exception as e:
        critical("Can't get groups list",exc=e)

########### TEMPLATES

@thing.group("template",help="")
def template():
    pass


@template.command("add",help="")
@click.argument("name")
def __add_template(name):
    """

.. _ztc-cmd-thing-template-add:

Create a device template
------------------------

The Zerynth ADM allows to remotely store a graphical interface for each connected device called device template.
A template is just a collection of HTML5, javascript, css and image files hosted on the ADM backend. The template is
able to receive and send messages to the connected device in response to user interactions with its graphical components.

The command: ::

    ztc thing template add name

creates a new empty template named :samp:`name`. A template is identified by a generated uid.

    """    
    tminfo = {"name":name}
    try:
        res = zpost(url=env.thing.templates, data=tminfo,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            if env.human:
                info("Template",name,"created with uid:",rj["data"]["uid"])
            else:
                log_json(rj["data"])
        else:
            critical("Error while creating template:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't create template", exc=e)


@template.command("upload",help="")
@click.argument("uid")
@click.argument("path")
def __upload_template(uid,path):
    """

.. _ztc-cmd-thing-template-upload:

Upload a template
-----------------

A newly created template is empty. Files and subfolders can be added to the template with the following command: ::

    ztc thing template upload uid path

where :samp:`path` is the folder containing the template files and :samp:`uid` is the uid indentifying the template to update.

The files at :samp:`path` are compressed and transferred to the ADM backend. There are limitations on the size of a template and on the type of files
that can be uploaded. If the upload is successfull, the files previously associated with the template are erased permanently (no history is kept).

    """    
    tmpath = fs.get_tempdir()
    tmpfile =fs.path(tmpath,"template.tar.xz")
    fs.tarxz(path,tmpfile)
    content = fs.readfile(tmpfile,"b")
    fs.del_tempdir(tmpath)
    data = {
        "archive":base64.standard_b64encode(content).decode("utf8")
    } 
    try:
        res = zput(url=env.thing.template%uid, data=data,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't update group", exc=e)


@template.command("list",help="")
@click.option("--from","_from",default=0,type=int,help="skip the first n templates")
def __templates(_from):
    """

.. _ztc-cmd-thing-template-list:

Retrieve template list
----------------------

The command: ::

    ztc thing template list

retrieves all the created templates. The option :option:`--from n` skips the first :samp:`n` templates.
    
    """
    table=[]
    try:
        prms = {"from":_from}
        res = zget(url=env.thing.templates,params=prms)
        rj = res.json()
        if rj["status"]=="success":
            if env.human:
                for k in rj["data"]["templates"]:
                    table.append([_from,k["uid"],k["name"],k["createdAt"]])
                    _from += 1
                log_table(table,headers=[str(rj["data"]["total"]),"UID","Name","Created"])
            else:
                log_json(rj["data"])
        else:
            critical("Can't get templates list",rj["message"])
    except Exception as e:
        critical("Can't get templates list",exc=e)



@cli.group(help="Manage OTA updates")
def ota():
    pass

@ota.command()
@click.argument("device",type=str)
@click.argument("pack",type=click.Path())
def prepare(device,pack):
    otaj = fs.get_json(pack)
    data = {
        "bcbin":otaj.get("bcbin",""),
        "vmbin":otaj.get("vmbin",""),
        "vmslot": otaj.get("vm_idx") if otaj.get("vmbin","") else 0,
        "bcslot": otaj.get("bc_idx") if otaj.get("bcbin","") else 0,
        "vmuid": otaj["vmuid"]
    }
    try:
        res = zpost(url=env.thing.ota%device, data=data,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't prepare OTA request", exc=e)



@ota.command()
@click.argument("device",type=str)
def start(device):
    try:
        res = zput(url=env.thing.ota%device,data={},timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't prepare OTA request", exc=e)

@ota.command()
@click.argument("device",type=str)
def stop(device):
    try:
        res = zdelete(url=env.thing.ota%device,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't prepare OTA request", exc=e)

@ota.command()
@click.argument("device")
def check(device):
    try:
        res = zget(url=env.thing.ota%device)
        rj = res.json()
        if rj["status"]=="success":
            data = rj["data"]
            if env.human:
                table=[]
                if data["ota_support"]:
                    #has ota info
                    pass
                else:
                    pass
                table.append([data])
                log_table(table,headers=[])
            else:
                log_json(data)
        else:
            critical("Can't check device status:",rj["message"])
    except Exception as e:
        critical("Can't check device status:",exc=e)

