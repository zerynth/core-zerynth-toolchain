"""
.. _ztc-cmd-thing:

*****************
Connected Devices
*****************

The Zerynth Advanced Device Manager (ADM) allows connections between the devices programmed with Zerynth and the ADM sandbox instance hosted on the Zerynth backend server.
The ADM adds to each connected device the following functionalities:

    * executing functions triggered by a remote request (remote procedure call)
    * performing over the air firmware update (FOTA)
    * displaying and interacting with a graphical user interface both on a mobile app or desktop browser

Such functionalities can be configured and controlled through the following ZTC commands:

* :ref:`Create a connected device <ztc-cmd-thing-add>`
* :ref:`Retrieve info on a connected device <ztc-cmd-thing-info>`
* :ref:`Set properties of a connected device <ztc-cmd-thing-config>`
* :ref:`Retrieve the list of connected devices <ztc-cmd-thing-list>`

* :ref:`Create groups of devices <ztc-cmd-thing-group-add>`
* :ref:`Add a connected device to a group <ztc-cmd-thing-group-config>`
* :ref:`List groups of devices <ztc-cmd-thing-group-list>`

* :ref:`Create a graphical template <ztc-cmd-thing-template-add>`
* :ref:`Update a graphical template <ztc-cmd-thing-template-upload>`
* :ref:`List all graphical templates <ztc-cmd-thing-template-list>`


* :ref:`Prepare for a FOTA update <ztc-cmd-ota-prepare>`
* :ref:`Check for FOTA status <ztc-cmd-ota-check>`
* :ref:`Start a FOTA update <ztc-cmd-ota-start>`
* :ref:`Stop a FOTA update <ztc-cmd-ota-stop>`


Details about the ADM can be found :ref:`here <zadm>. Info on how to write a Zerynth script for the ADM can be found :ref:`here <lib.zerynth.zadm>`.


    """

from base import *
import click
import base64


@cli.group(help="Manage connected devices")
def thing():
    pass
    

@thing.command("add",help="")
@click.argument("name")
@click.option("--platform",default="",type=str)
@click.option("--location",default="",type=str)
@click.option("--description",default="",type=str)
@click.option("--lat",default=0.0, type=float)
@click.option("--lon",default=0.0, type=float)
@click.option("--tag",multiple=True, type=str)
def __add(platform,name,location,tag,lat,lon,description):
    """ 

.. _ztc-cmd-thing-add:

Create a connected device
-------------------------

In order to connect a physical device to the ADM, a bit of device provisioning must be made. In particular, a new connected device
instance must be created on the ADM and the assigned credentials used in the script running on the physical device. 

The command: ::

    ztc thing add name

creates a new connected device instance with name :samp:`name` in the ADM server. Such instance can have many different properties, but only a subset of them is mandatory and generated by the ADM:

* :samp:`uid`: the unique identifier of the connected device
* :samp:`token`: the security token used to authenticate the physical device to the ADM

Additional properties can be specified at the moment of creation by specifying the corresponding options:

* :option:`--location loc` adds the description of the location the physical device is placed
* :option:`--lat lat --lon lon` attaches coordinates to the device
* :option:`--description desc` specifies the device description
* :option:`--tag tag` attaches a set of tags to the device (the option can be given multiple times)

Each Zerynth user can create an unlimited number of connected devices instances, however only a subset of them is allowed to be connected to the ADM at the same moment.

    """
    thinfo = {
        "name":name,
        "platform":platform,
        "location":location,
        "description": description,
        "tags": tag,
        "geo": [lat,lon]
    }
    try:
        res = zpost(url=env.thing.devices, data=thinfo,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            thinfo["uid"]=rj["data"]["uid"]
            info("Thing",name,"created with uid:", thinfo["uid"])
        else:
            critical("Error while creating Thing:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't create Thing", exc=e)




@thing.command("info",help="")
@click.argument("uid")
def __info(uid):
    """

.. _ztc-cmd-thing-info:

Retrieves device info
---------------------

The command: ::

    ztc thing info uid

retrieves information about the connected device with unique identifier :samp:`uid`.

The information retrieved consists of:

* :samp:`token`, the security token for the device
* :samp:`name`, the device name
* :samp:`description`, the device description
* :samp:`location`, the description of the device location
* :samp:`geo`, the latitude and longitude of the device position
* :samp:`groups`, the list of groups the device belongs to
* :samp:`last_seen`, the time of the last detected presence of the connected device
* :samp:`online`, the status of the device connection
* :samp:`platform`, the type of the physical device using this connected device credentials
* :samp:`notifications`, a boolean determing if mobile notifications are enabled for this device

    """

    try:
        res = zget(url=env.thing.config%uid)
        rj = res.json()
        if rj["status"] == "success":
            if env.human:
                table=[]
                k = rj["data"]
                table.append([k["platform"],k["uid"],k["token"],k["name"],k["description"],k["location"],k["geo"],k.get("groups",[]),k.get("last_seen"),k.get("online",False),k["notifications"]])
                log_table(table,headers=["Target","UID","Token","Name","Desc","Location","Coords","Groups","Last Seen","Online","Notifications"])
            else:
                log_json(rj["data"])
        else:
            critical("Error while getting Thing:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't get Thing", exc=e)
    

@thing.command("config",help="")
@click.argument("uid")
@click.option("--name",default="",type=str)
@click.option("--location",default="",type=str)
@click.option("--description",default="",type=str)
@click.option("--lat",default=0.0, type=float)
@click.option("--lon",default=0.0, type=float)
@click.option("--template",default=None, type=str)
@click.option("--notifications",default=None, type=str)
@click.option("--fullscreen",default=None, type=str)
@click.option("--token",default=False,flag_value=True)
def __config(uid,name,location,description,lat,lon,template,token,notifications,fullscreen):
    """

.. _ztc-cmd-thing-config:

Configure a device
------------------

The command: ::

    ztc thing config uid

sets the properties of the connected device with unique identifier :samp:`uid`.

The properties are specified with the following options:

* :option:`--name name`, changes the device name
* :option:`--description desc `, changes the device description
* :option:`--location loc`, changes the device location
* :option:`--lat x / --lon y`, change the device coordinates
* :option:`--token`, asks for a new security token
* :option:`--template template_uid`, sets the device template

    """
    data = {}
    if name:
        data["name"]=name
    if location:
        data["location"]=location
    if description:
        data["description"]=description
    if lat and lon:
        data["geo"]=[lat,lon]
    if template is not None:
        data["template"] = template
    if notifications is not None:
        data["notifications"] = True if int(notifications)!=0 else False
    if fullscreen is not None:
        data["fullscreen"] = True if int(fullscreen)!=0 else False
    if token:
        data["token"] = True
    try:
        res = zput(url=env.thing.config%uid,data=data)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error while getting Thing:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't get Thing", exc=e)

@thing.command("list",help="")
@click.option("--from","_from",default=0,type=int,help="skip the first n connected devices")
@click.option("--status",default="all",type=click.Choice(["all","online","offline"]),help="skip the first n Things")
def __list(_from,status):
    """

.. _ztc-cmd-thing-list:

Connected devices list
----------------------

The command: ::

    ztc thing config list

retrieves the list of connected devices. Options can be specified to filter the results:

* :option:`--from n`, skips the first :samp:`n` connected devices. Default :samp:`n` is zero.
* :option:`--status online/offline`, filters connected devices based on online status. If not given, all devices are retrieved

    """
    table=[]
    try:
        prms = {"from":_from,"status":status}
        res = zget(url=env.thing.devices,params=prms)
        rj = res.json()
        if rj["status"]=="success":
            if env.human:
                for k in rj["data"]["devices"]:
                    table.append([_from,k["platform"],k["uid"],k["token"],k["name"],k["description"],k["location"],k["geo"],k.get("groups",[]),k.get("last_seen",False),k.get("online",False),k["notifications"]])
                    _from += 1
                log_table(table,headers=[str(rj["data"]["total"]),"Target","UID","Token","Name","Desc","Location","Coords","Groups","Last Seen","Online","Notifications"])
            else:
                log_json(rj["data"])
        else:
            critical("Can't get thing list",rj["message"])
    except Exception as e:
        critical("Can't get thing list",exc=e)





########### GROUPS

@thing.group("group",help="")
def group():
    pass


@group.command("add",help="")
@click.argument("name")
def __add_group(name):
    """

.. _ztc-cmd-thing-group-add:

Create a group of devices
-------------------------

The command: ::

    ztc thing group add name

creates a group named :samp:`name`, initially empty. 
Devices can be added to the group with the :ref:`config <ztc-thing-group-config>` command.


    """
    grinfo = {"name":name}
    try:
        res = zpost(url=env.thing.groups, data=grinfo,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            if env.human:
                info("Group",name,"created with uid",rj["data"]["uid"])
            else:
                log_json(rj["data"])
        else:
            critical("Error while creating group:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't create group", exc=e)


@group.command("config",help="")
@click.argument("uid")
@click.option("--add",multiple=True,type=str)
@click.option("--remove",multiple=True,type=str)
def __config_group(uid,add,remove):
    """
.. _ztc-cmd-thing-group-config:

Group configuration
-------------------

The command: ::

    ztc thing group config uid --add dev0_uid --remove dev1_uid

can be used to add or remove devices (identified by their uids :samp:`dev0_uid` and :samp:`dev1_uid`) to the group identifiedby :samp:`uid`.

The options :option:`--add` and :option:`--remove` can be repeated multiple times in the same command.

    """
    data = {}
    for x in add:
        data[x]=1
    for x in remove:
        data[x]=0
    try:
        res = zput(url=env.thing.group%uid, data=data,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't update group", exc=e)


@group.command("list",help="")
@click.option("--from","_from",default=0,type=int,help="skip the first n groups")
def __groups(_from):
    """

.. _ztc-cmd-thing-group-list:

Group configuration
-------------------

The command: ::

    ztc thing group list

retrieves the list of all groups. The option :option:`--from n` can be used to skip the first :samp:`n` groups.

    """    
    table=[]
    try:
        prms = {"from":_from}
        res = zget(url=env.thing.groups,params=prms)
        rj = res.json()
        if rj["status"]=="success":
            if env.human:
                for k in rj["data"]["groups"]:
                    table.append([_from,k["uid"],k["name"],k["createdAt"]])
                    _from += 1
                log_table(table,headers=[str(rj["data"]["total"]),"UID","Group","Created"])
            else:
                log_json(rj["data"])
        else:
            critical("Can't get groups list",rj["message"])
    except Exception as e:
        critical("Can't get groups list",exc=e)

########### TEMPLATES

@thing.group("template",help="")
def template():
    pass


@template.command("add",help="")
@click.argument("name")
def __add_template(name):
    """

.. _ztc-cmd-thing-template-add:

Create a device template
------------------------

The Zerynth ADM allows to remotely store a graphical interface for each connected device called device template.
A template is just a collection of HTML5, javascript, css and image files hosted on the ADM backend. The template is
able to receive and send messages to the connected device in response to user interactions with its graphical components.

The command: ::

    ztc thing template add name

creates a new empty template named :samp:`name`. A template is identified by a generated uid.

    """    
    tminfo = {"name":name}
    try:
        res = zpost(url=env.thing.templates, data=tminfo,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            if env.human:
                info("Template",name,"created with uid:",rj["data"]["uid"])
            else:
                log_json(rj["data"])
        else:
            critical("Error while creating template:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't create template", exc=e)


@template.command("upload",help="")
@click.argument("uid")
@click.argument("path")
def __upload_template(uid,path):
    """

.. _ztc-cmd-thing-template-upload:

Upload a template
-----------------

A newly created template is empty. Files and subfolders can be added to the template with the following command: ::

    ztc thing template upload uid path

where :samp:`path` is the folder containing the template files and :samp:`uid` is the uid indentifying the template to update.

The files at :samp:`path` are compressed and transferred to the ADM backend. There are limitations on the size of a template and on the type of files
that can be uploaded. If the upload is successfull, the files previously associated with the template are erased permanently (no history is kept).

    """    
    tmpath = fs.get_tempdir()
    tmpfile =fs.path(tmpath,"template.tar.xz")
    fs.tarxz(path,tmpfile)
    content = fs.readfile(tmpfile,"b")
    fs.del_tempdir(tmpath)
    data = {
        "archive":base64.standard_b64encode(content).decode("utf8")
    } 
    try:
        res = zput(url=env.thing.template%uid, data=data,timeout=60)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't update template", exc=e)


@template.command("list",help="")
@click.option("--from","_from",default=0,type=int,help="skip the first n templates")
def __templates(_from):
    """

.. _ztc-cmd-thing-template-list:

Retrieve template list
----------------------

The command: ::

    ztc thing template list

retrieves all the created templates. The option :option:`--from n` skips the first :samp:`n` templates.
    
    """
    table=[]
    try:
        prms = {"from":_from}
        res = zget(url=env.thing.templates,params=prms)
        rj = res.json()
        if rj["status"]=="success":
            if env.human:
                for k in rj["data"]["templates"]:
                    table.append([_from,k["uid"],k["name"],k["createdAt"]])
                    _from += 1
                log_table(table,headers=[str(rj["data"]["total"]),"UID","Name","Created"])
            else:
                log_json(rj["data"])
        else:
            critical("Can't get templates list",rj["message"])
    except Exception as e:
        critical("Can't get templates list",exc=e)



@cli.group(help="Manage OTA updates")
def ota():
    pass

@ota.command()
@click.argument("device",type=str)
@click.argument("pack",type=click.Path())
def prepare(device,pack):
    """

.. _ztc-cmd-ota-prepare:

Prepare a FOTA update
---------------------

The command: ::

    ztc ota prepare device firmware

uploads to the ADM instance the correctly compiled and linked firmware update contained in the :samp:`firmware` file for device with uid :samp:`device`.
To correctly prepare a FOTA update refer to the :ref:`link <ztc-cmd-link> command`.

    """

    otaj = fs.get_json(pack)
    data = {
        "bcbin":otaj.get("bcbin",""),
        "vmbin":otaj.get("vmbin",""),
        "vmslot": otaj.get("vm_idx"),
        "bcslot": otaj.get("bc_idx"),
        "vmuid": otaj["vmuid"]
    }
    try:
        res = zpost(url=env.thing.ota%device, data=data,timeout=20)
        debug(res.text)
        rj = res.json()
        if rj["status"] == "success":
            info("FOTA request prepared with uid:",rj["data"]["uid"])
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't prepare OTA request", exc=e)



@ota.command()
@click.argument("device",type=str)
def start(device):
    """

.. _ztc-cmd-ota-start:

Start a FOTA update
-------------------

The command: ::

    ztc ota start device

signals the ADM to start the previously prepared FOTA update for device :samp:`device`.

    """
    try:
        res = zput(url=env.thing.ota%device,data={},timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't prepare OTA request", exc=e)

@ota.command()
@click.argument("device",type=str)
def stop(device):
    """
    
.. _ztc-cmd-ota-stop:

Stop a FOTA update
------------------

The command: ::

    ztc ota stop device

signals the ADM to stop the previously prepared or started FOTA update for device :samp:`device`.

    """
    try:
        res = zdelete(url=env.thing.ota%device,timeout=20)
        rj = res.json()
        if rj["status"] == "success":
            info("Ok")
        else:
            critical("Error:", rj["message"])
    except TimeoutException as e:
        critical("No answer yet")
    except Exception as e:
        critical("Can't prepare OTA request", exc=e)

@ota.command()
@click.argument("device")
def check(device):
    """
    
.. _ztc-cmd-ota-check:

Check a FOTA update
-------------------

The command: ::

    ztc ota check device

display the status of the FOTA process for :samp:`device`.
The displayed information is:

    * :samp:`ota_support`, ``True`` if the connected device runs a FOTA enabled VM
    * :samp:`bcslot`, the index of the slot the current bytecode is running on
    * :samp:`vmslot`, the index of the slot the current VM is running on
    * :samp:`vmuid`, the unique identifier of the running VM
    * :samp:`ota_request`, a unique identifier specifying the ongoing FOTA update, empty if FOTA is not ongoing
    * :samp:`ota_next_request`, a unique identifier specifying the FOTA update that will be started by the :ref:`start command <ztc-cmd-ota-start>`, empty if no FOTA has been :ref:`prepared <ztc-cmd-ota-prepare>`
    * :samp:`ota_fail`, a message specifying the last failed FOTA update error message, empty if ok
    * :samp:`last_ota`, the timestamp of last successful FOTA update


    """
    try:
        res = zget(url=env.thing.ota%device)
        rj = res.json()
        if rj["status"]=="success":
            data = rj["data"]
            if env.human:
                table=[]
                if data["ota_support"]:
                    #has ota info
                    pass
                else:
                    pass
                table.append([data])
                log_table(table,headers=[])
            else:
                log_json(data)
        else:
            critical("Can't check device status:",rj["message"])
    except Exception as e:
        critical("Can't check device status:",exc=e)


def _monitor_open(wss):
    pass

def _monitor_message(wss,msg):
    log(msg)

def _monitor_error(wss,error):
    #info("ERROR",error)
    pass

def _monitor_close(wss):
    pass

@ota.command()
def monitor():
    hh = get_token_headers()
    wss = ws.WebSocketApp(env.thing.monitor,header=hh,on_open = _monitor_open, on_message = _monitor_message, on_close = _monitor_close, on_error = _monitor_error)
    wss.run_forever(ping_interval=30)
    log("byebye")
